I"H.<h2 id="proofs">Proofs</h2>

<p>I said everything in Lean has a type. What is the type of a 
proof of a formula <code class="language-plaintext highlighter-rouge">X : Prop</code>? Let’s call the proof <code class="language-plaintext highlighter-rouge">h</code>.</p>

<p>Well, its type is <code class="language-plaintext highlighter-rouge">X</code> itself. In addition to being a term in 
the (big) type of <code class="language-plaintext highlighter-rouge">Prop</code>, <code class="language-plaintext highlighter-rouge">X</code> is itself a type whose terms 
are proofs of <code class="language-plaintext highlighter-rouge">X</code>.</p>

<p>We can of course declare we have a proof (without providing 
one) by saying</p>

<figure class="highlight"><pre><code class="language-lean" data-lang="lean"><span class="k">variable</span> (<span class="n">A</span> : <span class="kt">Prop</span>) 
<span class="k">variable</span> (<span class="n">h</span> : <span class="n">A</span>)</code></pre></figure>

<p>But far more important for us is <em>producing</em> proofs!</p>

<p>Before we look at some basic examples, let’s introduce two new 
keywords for Lean: <code class="language-plaintext highlighter-rouge">example</code> and <code class="language-plaintext highlighter-rouge">theorem</code>. Both of these tell 
Lean that we want to produce a proof for a particular proposition. 
Here are some examples:</p>

<figure class="highlight"><pre><code class="language-lean" data-lang="lean"><span class="k">variable</span> (<span class="n">A</span> : <span class="kt">Prop</span>) 
<span class="k">example</span> : <span class="n">A</span> := <span class="n">sorry</span> 
<span class="k">theorem</span> <span class="n">bigOne</span> : <span class="n">A</span> := <span class="n">sorry</span></code></pre></figure>

<p>The main difference between <code class="language-plaintext highlighter-rouge">example</code> and <code class="language-plaintext highlighter-rouge">theorem</code> is that <code class="language-plaintext highlighter-rouge">theorem</code> 
expects a name whereas <code class="language-plaintext highlighter-rouge">example</code> does not.</p>

<p>Each of these is telling Lean that I am going to provide a proof 
of <code class="language-plaintext highlighter-rouge">A</code>. This is why we end the statement with <code class="language-plaintext highlighter-rouge">: A</code>. It is informing 
Lean the type of the coming proof.</p>

<p>The proof goes after <code class="language-plaintext highlighter-rouge">:=</code>. <code class="language-plaintext highlighter-rouge">sorry</code> is a special command 
that decreases the volume of the complaints from Lean that we 
did not actually provide a proof. If we remove <code class="language-plaintext highlighter-rouge">sorry</code>, we notice 
that the message is in red now: <code class="language-plaintext highlighter-rouge">unexpected end of input</code>.</p>

<p>Messages like these from the infoview pane are meant to be helpful 
in constructing our proofs but they can be cryptic. A good rule is 
to step back a little and meditate on the error message in the 
context of the question.</p>

<p>In general, we cannot produce a proof out of nothing except for 
situations. Even so, they are instructive to investigate.</p>

<p>Suppose I want to establish $A \vdash A$. This is trivial in 
propositional logic: I have $A$ so I have $A$. How does this 
look in Lean?</p>

<p>For examples/theorems, we can put the assumptions on the left-hand 
side of the semi-colon.</p>

<figure class="highlight"><pre><code class="language-lean" data-lang="lean"><span class="k">example</span> (<span class="n">h</span> : <span class="n">A</span>) : <span class="n">A</span> := <span class="n">sorry</span> </code></pre></figure>

<p>This reads as: “assume I have a proof <code class="language-plaintext highlighter-rouge">h</code> of <code class="language-plaintext highlighter-rouge">A</code> and I want to prove <code class="language-plaintext highlighter-rouge">A</code>”.
A completed proof is:</p>

<figure class="highlight"><pre><code class="language-lean" data-lang="lean"><span class="k">example</span> (<span class="n">h</span> : <span class="n">A</span>) : <span class="n">A</span> := <span class="n">h</span> </code></pre></figure>

<p>You are providing the assumed proof of <code class="language-plaintext highlighter-rouge">A</code> as the desired proof of <code class="language-plaintext highlighter-rouge">A</code>.</p>

<p>A formula we can always prove is $\top$. In Lean, this proposition is called 
<code class="language-plaintext highlighter-rouge">True</code> and $\bot$ goes by <code class="language-plaintext highlighter-rouge">False</code>.</p>

<p>The introduction rule for <code class="language-plaintext highlighter-rouge">True</code> comes in the form of a canonical proof 
called <code class="language-plaintext highlighter-rouge">true</code> of type <code class="language-plaintext highlighter-rouge">True</code>.</p>

<h2 id="implication-elimination-and-introduction">Implication elimination and introduction</h2>

<p>Our rules of inference allowed us to build more complicated proofs from some 
basic steps. Each rule is encoded in Lean. Let’s start by looking at the 
introduction and elimination rules for implication.</p>

<p>Say we have <code class="language-plaintext highlighter-rouge">A B : Prop</code> and we want to prove <code class="language-plaintext highlighter-rouge">B</code> from <code class="language-plaintext highlighter-rouge">A → B</code> and <code class="language-plaintext highlighter-rouge">A</code>. This 
is done as</p>

<figure class="highlight"><pre><code class="language-lean" data-lang="lean"><span class="k">variable</span> (<span class="n">A</span> <span class="n">B</span> : <span class="kt">Prop</span>) 
<span class="k">example</span> (<span class="n">f</span> : <span class="n">A</span> <span class="o">→</span> <span class="n">B</span>) (<span class="n">h</span> : <span class="n">A</span>) : <span class="n">B</span> := <span class="n">f</span> <span class="n">h</span></code></pre></figure>

<p>What is going on here? <code class="language-plaintext highlighter-rouge">h</code> is a proof of <code class="language-plaintext highlighter-rouge">A</code> as before and <code class="language-plaintext highlighter-rouge">f</code> is a proof 
of <code class="language-plaintext highlighter-rouge">A → B</code>. What is a proof of <code class="language-plaintext highlighter-rouge">A → B</code>? Well, one way to understand it is 
as a way to turn a proof of <code class="language-plaintext highlighter-rouge">A</code> into a proof <code class="language-plaintext highlighter-rouge">B</code>. We generally call such 
things <em>functions</em>.</p>

<p>By placing <code class="language-plaintext highlighter-rouge">f h</code>, we are saying “feed <code class="language-plaintext highlighter-rouge">h</code> into <code class="language-plaintext highlighter-rouge">f</code> and use the output”. A more 
common way to say it is that we <em>applied</em> <code class="language-plaintext highlighter-rouge">f</code> to <code class="language-plaintext highlighter-rouge">h</code>.</p>

<p>Application of <code class="language-plaintext highlighter-rouge">f</code> of <code class="language-plaintext highlighter-rouge">h</code> is how $\to$-elimination is implemented in Lean.</p>

<p>Next we look at $\to$-introduction. For example, how would we finish the following?</p>

<figure class="highlight"><pre><code class="language-lean" data-lang="lean"><span class="k">variable</span> (<span class="n">A</span> : <span class="kt">Prop</span>)
<span class="k">example</span> : <span class="n">A</span> <span class="o">→</span> <span class="n">A</span> := <span class="n">sorry</span></code></pre></figure>

<p>This difference between this example and</p>

<figure class="highlight"><pre><code class="language-lean" data-lang="lean"><span class="k">example</span> (<span class="n">h</span> : <span class="n">A</span>) : <span class="n">A</span> := <span class="n">h</span> </code></pre></figure>

<p>is the exactly the elimination rule for implication.</p>

<p>We want to make a function <code class="language-plaintext highlighter-rouge">f : A → A</code> which mimics our intitution that given a 
proof <code class="language-plaintext highlighter-rouge">h : A</code> that we can output that given proof to get a proof of <code class="language-plaintext highlighter-rouge">A</code>.</p>

<p>The syntax for doing so is seen below in the completed example.</p>

<figure class="highlight"><pre><code class="language-lean" data-lang="lean"><span class="k">variable</span> (<span class="n">A</span> : <span class="kt">Prop</span>)
<span class="k">example</span> : <span class="n">A</span> <span class="o">→</span> <span class="n">A</span> := <span class="k">fun</span> (<span class="n">h</span>:<span class="n">A</span>) <span class="o">=&gt;</span> <span class="n">h</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">fun</code> tells Lean that a function is coming <code class="language-plaintext highlighter-rouge">(h : A)</code> specifies the input (and its 
type). The arrow <code class="language-plaintext highlighter-rouge">=&gt;</code> separates the input from the output.</p>

<p>Strictly speaking this is not the implication introduction rule but it plays an 
important part.</p>

<figure class="highlight"><pre><code class="language-lean" data-lang="lean"><span class="k">variable</span> <span class="err">{</span><span class="n">A</span> <span class="n">B</span> : <span class="kt">Prop</span><span class="err">}</span> 
<span class="k">theorem</span> <span class="n">superProof</span> (<span class="n">h</span> : <span class="n">A</span>) : <span class="n">B</span> := <span class="n">sorry</span> 
<span class="k">example</span> : <span class="n">A</span> <span class="o">→</span> <span class="n">B</span> := <span class="k">fun</span> (<span class="n">h</span> : <span class="n">A</span>) <span class="o">=&gt;</span> <span class="n">superProof</span> <span class="n">h</span></code></pre></figure>

<p>We can treat the (nonexistent) proof of our theorem as a function.</p>

<p>But you may have noticed the braces <code class="language-plaintext highlighter-rouge">{ A B : Prop }</code>. When we declare <code class="language-plaintext highlighter-rouge">(A : Prop)</code>, 
Lean adds it as an assumption to all examples/theorems in our file. So really 
superProof has the form</p>

<figure class="highlight"><pre><code class="language-lean" data-lang="lean"><span class="k">theorem</span> <span class="err">{</span><span class="n">A</span> <span class="n">B</span> : <span class="kt">Prop</span><span class="err">}</span> <span class="n">superProof</span> (<span class="n">h</span> : <span class="n">A</span>) : <span class="n">B</span> := <span class="n">sorry</span> </code></pre></figure>

<p>Using the parentheses <code class="language-plaintext highlighter-rouge">(A B : Prop)</code> tells Lean that I want <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> to also be (explicit) 
inputs to <code class="language-plaintext highlighter-rouge">superProof</code>. (When we saying <code class="language-plaintext highlighter-rouge">variable</code> to Lean, it really goes all out.)</p>

<p>Using the braces <code class="language-plaintext highlighter-rouge">{A B : Prop}</code> tells Lean “you figure out <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>” from the 
other information. Which is can do in the case of our example from the desired type is 
<code class="language-plaintext highlighter-rouge">A → B</code>.</p>
:ET